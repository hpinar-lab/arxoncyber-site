<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arxon Cyber — From Packets to Prompts</title>
    <meta name="description" content="Arxon Cyber — Unified Cyber Defense Platform. From Packets to Prompts — Total Security Intelligence.">
    <link rel="icon" type="image/svg+xml" href="https://raw.githubusercontent.com/hpinar-lab/arxoncyber-site/0101a4c4f86ea0a207940dc52e6549fdd0c2eb59/favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jura:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #060c16;
            font-family: 'Jura', sans-serif;
            cursor: default;
        }

        canvas#network {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100%;
            pointer-events: none;
        }

        /* Logo */
        .logo-group {
            display: flex;
            align-items: baseline;
            gap: 14px;
            margin-bottom: 8px;
            animation: fadeInDown 1.5s ease-out;
        }

        .logo-arxon {
            font-size: clamp(48px, 8vw, 96px);
            font-weight: 500;
            color: #ffffff;
            letter-spacing: 0.06em;
            line-height: 1;
        }

        .logo-cyber {
            font-size: clamp(36px, 6vw, 72px);
            font-weight: 300;
            color: #00b4d8;
            letter-spacing: 0.08em;
            line-height: 1;
        }

        /* Accent line */
        .accent-line {
            width: clamp(300px, 50vw, 650px);
            height: 1px;
            background: rgba(42, 157, 143, 0.4);
            margin: 16px 0 36px 0;
            animation: fadeIn 2s ease-out 0.5s both;
        }

        /* Statement */
        .statement {
            max-width: 700px;
            text-align: center;
            padding: 0 24px;
            animation: fadeInUp 1.8s ease-out 0.8s both;
        }

        .statement p {
            font-size: clamp(15px, 2vw, 19px);
            font-weight: 300;
            color: #8899aa;
            line-height: 1.75;
            letter-spacing: 0.02em;
        }

        .statement em {
            color: #00b4d8;
            font-style: normal;
            font-weight: 400;
        }

        /* Tagline */
        .tagline {
            margin-top: 40px;
            font-size: clamp(10px, 1.3vw, 13px);
            font-weight: 400;
            color: #5a7a92;
            letter-spacing: 0.25em;
            text-transform: uppercase;
            animation: fadeIn 2s ease-out 1.5s both;
        }

        /* Etymology */
        .etymology {
            margin-top: 14px;
            font-size: 11px;
            font-weight: 300;
            color: #4a6a85;
            letter-spacing: 0.1em;
            font-family: 'Courier New', monospace;
            animation: fadeIn 2.5s ease-out 2s both;
        }

        /* Footer */
        .footer {
            position: fixed;
            bottom: 28px;
            left: 0;
            right: 0;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            animation: fadeIn 2s ease-out 2.5s both;
        }

        .footer span {
            font-size: 11px;
            font-weight: 300;
            color: #4a6275;
            letter-spacing: 0.15em;
        }

        /* Animations */
        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Responsive */
        @media (max-width: 600px) {
            .logo-group {
                flex-direction: column;
                align-items: center;
                gap: 0;
            }
            .logo-cyber {
                margin-top: -4px;
            }
        }
    </style>
</head>
<body>

<canvas id="network"></canvas>

<div class="content">
    <div class="logo-group">
        <span class="logo-arxon">ARXON</span>
        <span class="logo-cyber">CYBER</span>
    </div>

    <div class="accent-line"></div>

    <div class="statement">
        <p>
            Modern threats don't respect layer boundaries. Neither should your defense.
            <br><br>
            Arxon Cyber is building the <em>unified defense platform</em> that protects enterprises 
            from network packets to AI prompts — eliminating the blind spots 
            that exist between traditional security and the new AI attack surface.
        </p>
    </div>

    <div class="tagline">From Packets to Prompts — Total Security Intelligence</div>

    <div class="etymology">arx · Latin · fortress, citadel, stronghold</div>
</div>

<div class="footer">
    <span>© 2026 Arxon Cyber · Tekpark Bilişim Teknolojileri</span>
</div>

<script>
    const canvas = document.getElementById('network');
    const ctx = canvas.getContext('2d');

    let width, height, nodes, mouse, dpr;

    const CONFIG = {
        nodeCount: 660,
        connectionDistance: 180,
        mouseRadius: 200,
        mouseForce: 0.08,
        returnForce: 0.015,
        friction: 0.92,
        baseSpeed: 0.15,
        colors: {
            node: 'rgba(0, 180, 216, ',
            connection: 'rgba(0, 180, 216, ',
            mouseLine: 'rgba(0, 180, 216, ',
        }
    };

    mouse = { x: -1000, y: -1000 };

    class Node {
        constructor() {
            this.reset();
            this.size = 1.5 + Math.random() * 1.2;
        }

        reset() {
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            this.originX = this.x;
            this.originY = this.y;
            this.vx = (Math.random() - 0.5) * CONFIG.baseSpeed;
            this.vy = (Math.random() - 0.5) * CONFIG.baseSpeed;
        }

        update() {
            // Mouse interaction
            const dx = this.x - mouse.x;
            const dy = this.y - mouse.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < CONFIG.mouseRadius && dist > 0) {
                const force = (CONFIG.mouseRadius - dist) / CONFIG.mouseRadius;
                const angle = Math.atan2(dy, dx);
                this.vx += Math.cos(angle) * force * CONFIG.mouseForce;
                this.vy += Math.sin(angle) * force * CONFIG.mouseForce;
            }

            // Gentle drift
            this.originX += (Math.random() - 0.5) * 0.1;
            this.originY += (Math.random() - 0.5) * 0.1;

            // Keep origins in bounds
            if (this.originX < 0) this.originX = 0;
            if (this.originX > width) this.originX = width;
            if (this.originY < 0) this.originY = 0;
            if (this.originY > height) this.originY = height;

            // Return to origin
            const returnDx = this.originX - this.x;
            const returnDy = this.originY - this.y;
            this.vx += returnDx * CONFIG.returnForce;
            this.vy += returnDy * CONFIG.returnForce;

            // Friction
            this.vx *= CONFIG.friction;
            this.vy *= CONFIG.friction;

            // Update position
            this.x += this.vx;
            this.y += this.vy;
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 180, 216, 0.6)';
            ctx.fill();
        }
    }

    function drawConnections() {
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const dx = nodes[i].x - nodes[j].x;
                const dy = nodes[i].y - nodes[j].y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < CONFIG.connectionDistance) {
                    const alpha = (1 - dist / CONFIG.connectionDistance) * 0.45;
                    ctx.beginPath();
                    ctx.moveTo(nodes[i].x, nodes[i].y);
                    ctx.lineTo(nodes[j].x, nodes[j].y);
                    ctx.strokeStyle = CONFIG.colors.connection + alpha.toFixed(3) + ')';
                    ctx.lineWidth = 0.6;
                    ctx.stroke();
                }
            }
        }

        // Mouse connections - draw lines from mouse to nearby nodes
        for (let i = 0; i < nodes.length; i++) {
            const dx = nodes[i].x - mouse.x;
            const dy = nodes[i].y - mouse.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < CONFIG.mouseRadius * 1.2) {
                const alpha = (1 - dist / (CONFIG.mouseRadius * 1.2)) * 0.55;
                ctx.beginPath();
                ctx.moveTo(mouse.x, mouse.y);
                ctx.lineTo(nodes[i].x, nodes[i].y);
                ctx.strokeStyle = CONFIG.colors.mouseLine + alpha.toFixed(3) + ')';
                ctx.lineWidth = 0.8;
                ctx.stroke();
            }
        }
    }

    function resize() {
        dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        if (nodes) {
            nodes.forEach(n => n.reset());
        }
    }

    function init() {
        resize();
        nodes = [];
        for (let i = 0; i < CONFIG.nodeCount; i++) {
            nodes.push(new Node());
        }
    }

    function animate() {
        ctx.clearRect(0, 0, width, height);

        // Subtle radial gradient background
        const grad = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, width * 0.7);
        grad.addColorStop(0, 'rgba(10, 20, 35, 1)');
        grad.addColorStop(1, 'rgba(6, 12, 22, 1)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, width, height);

        drawConnections();

        nodes.forEach(node => {
            node.update();
            node.draw();
        });

        requestAnimationFrame(animate);
    }

    // Event listeners
    window.addEventListener('resize', () => {
        resize();
    });

    document.addEventListener('mousemove', (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    });

    document.addEventListener('mouseleave', () => {
        mouse.x = -1000;
        mouse.y = -1000;
    });

    // Touch support
    document.addEventListener('touchmove', (e) => {
        if (e.touches.length > 0) {
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
        }
    }, { passive: true });

    document.addEventListener('touchend', () => {
        mouse.x = -1000;
        mouse.y = -1000;
    });

    // Start
    init();
    animate();
</script>

</body>
</html>
